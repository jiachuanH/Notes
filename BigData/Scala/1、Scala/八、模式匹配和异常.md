# ä¸€ã€æ¨¡å¼åŒ¹é…

> ç®€ä»‹

==ç±»ä¼¼äº Java ä¸­çš„ switch è¯­æ³•==

ä½†æ˜¯scalaä»è¯­æ³•ä¸­è¡¥å……äº†æ›´å¤šçš„åŠŸèƒ½ï¼Œå¯ä»¥æŒ‰ç…§æŒ‡å®šçš„è§„åˆ™**å¯¹æ•°æ®æˆ–å¯¹è±¡æˆ–ç±»è¿›è¡ŒåŒ¹é…**, æ‰€ä»¥æ›´åŠ å¼ºå¤§ã€‚

- **åŸºæœ¬è¯­æ³•**

  ```scala
      // 1 åŸºæœ¬å®šä¹‰è¯­æ³•
      val x = 6
      val y =
        x match {
          case 1 => "one"
          case 2 => "two"
          case 3 => "three"
          case _ => "other"
  
        }
  
      println(y)
  ```

  

- **æ³¨æ„**
  - å¦‚æœæ‰€æœ‰ case éƒ½ä¸åŒ¹é…ï¼Œé‚£ä¹ˆä¼šæ‰§è¡Œ case _ åˆ†æ”¯ï¼Œç±»ä¼¼äº Java ä¸­ default è¯­å¥ï¼Œ è‹¥æ­¤æ—¶æ²¡æœ‰ case _ åˆ†æ”¯ï¼Œé‚£ä¹ˆä¼šæŠ›å‡º MatchError
  - æ¯ä¸ª case ä¸­ï¼Œä¸éœ€è¦ä½¿ç”¨ break è¯­å¥ï¼Œè‡ªåŠ¨ä¸­æ–­ case
  - match case è¯­å¥å¯ä»¥åŒ¹é…ä»»ä½•ç±»å‹ï¼Œè€Œä¸åªæ˜¯å­—é¢é‡
  - => åé¢çš„ä»£ç å—   ä¸ç”¨{}



- **æ¡ˆä¾‹**

  ```scala
  // 2 ä¾‹å­ ç”¨æ¨¡å¼åŒ¹é…å®ç°ç®€å•äºŒå…ƒè¿ç®—
  val a =25
  val b =13
  
  
  
  def matchDualop(op :Char)=op match {
    case '+' =>  a+b
    case '-' =>  a-b
    case '*' =>  a*b
    case '/' =>  a/b
    case '%' =>  a%b
    case _ => "éæ³•è¿ç®—ç¬¦"
  
  }
  
  println(matchDualop('+'))
  println(matchDualop('-'))
  println(matchDualop('*'))
  println(matchDualop('/'))
  println(matchDualop('\\'))
  ```







## æ¨¡å¼å®ˆå«

- ç®€ä»‹
  - ==å…¶å®å°±æ˜¯åœ¨caseåé¢åŠ ä¸Šä¸ªæ¡ä»¶åˆ¤æ–­==
  - ç”¨äº**åŒ¹é…æŸä¸ªèŒƒå›´**çš„æ•°æ®

- å®æ“

  ```scala
     //3 æ¨¡å¼å®ˆå«
          // æ±‚ä¸€ä¸ªæ•´æ•°çš„ç»å¯¹å€¼
  
      def abs(num:Int):Int={
        num match {
          case i    if i >= 0   =>    i
          case i    if i <= 0   =>   -i
        }
      }
  
      println(abs(145))
      println(abs(0))
      println(abs(-35))
  ```



## åŒ¹é…ç±»å‹

### åŒ¹é…å¸¸é‡

------

> ç®€ä»‹

- Scalaå¯ä»¥åŒ¹é…
  - å­—ç¬¦ä¸²
  - å­—ç¬¦
  - æ•°å­—
  - å¸ƒå°”å€¼
  - ç­‰ç­‰

```scala
    //1 åŒ¹é…å¸¸é‡
    def describeConst(x:Any) :String=x match {
      case 1 => "a"
      case "hello" => "String hello"
      case true => "Boolean true"
      case '+' => "Char +"
      case _ => ""  // ä¸å¯èƒ½å…¨éƒ¨åŒ¹é… è®¾ç½®ä¸€ä¸ªå…œåº•çš„æ–¹æ³•

    }

    println(describeConst("hello"))
    println(describeConst('+'))
    println(describeConst("fewafcas"))

    println("=============================")

```



### åŒ¹é…æ•°æ®ç±»å‹

------

==ç±»ä¼¼äºå‰æ–‡æ‰€å­¦çš„ isInstanceOf[T]å’Œ asInstanceOf[T]æ–¹æ³•ï¼Œç”¨æ¨¡å¼åŒ¹é…å®ç°åŒæ ·çš„åŠŸèƒ½==



```scala
    //2  åŒ¹é…ç±»å‹
    def describeType(x:Any) :String=x match {
      case i:Int => "Int" + i
      case s:String => "String" +s
      case list :List[String] => "List " + list
      case array:Array[Int] => "Array[Int]"  + array.mkString(",")
      case a => "something else" + a  // ä¸å¯èƒ½å…¨éƒ¨åŒ¹é… è®¾ç½®ä¸€ä¸ªå…œåº•çš„æ–¹æ³•

    }
    println(describeType(55))
    println(describeType("hello"))
    println(describeType(List("lol","sad")))


    println(describeType(List(54,4)))
    /*               ?
     æ­¤å¤„èƒ½åŒ¹é…ä¸Šæ˜¯å› ä¸ºJVMä¸­æœ‰ä¸€ä¸ªå«æ³›å‹æ“¦é™¤çš„æ“ä½œ å¯¹Listç”Ÿæ•ˆ
     æ— è®ºListçš„æ³›å‹è®¾ç½®æˆä»€ä¹ˆéƒ½å¯ä»¥åŒ¹é…çš„åˆ°
     */


    println(describeType(Array("hello","hi"))) // Arrayæ˜¯éšå¼è½¬æ¢æ²¡æœ‰æ³›å‹æ“¦é™¤
    println(describeType(Array(54,4)))
```





### åŒ¹é…æ•°ç»„

------

```scala
    // 3 åŒ¹é…æ•°ç»„
    for (arr <- List(
     Array(0),
     Array(1,0),
     Array(0,1,0),
     Array(1,1,0),
     Array(2,3,7,15),
     Array("hello",55,95),


    )){
      val result =arr match {
        case Array(0) => "0"
        case Array(1,0) => "1,0"
        case Array(x,y) =>  "Array " + x + ", " + y  //åŒ¹é…ä¸¤å…ƒç´ æ•°ç»„
        case Array(0,_*) => "ä»¥0å¼€å¤´çš„æ•°ç»„"
        case Array(x,1,z) => "ä¸­é—´ä¸º1çš„ä¸‰å…ƒç´ æ•°ç»„"
        case _ => "something else"   //å…œåº•æ–¹æ³•
      }

      println(result)

    }
println("=================================")
```



### åŒ¹é…åˆ—è¡¨

------

- **æ–¹å¼ä¸€**

  ```scala
         //4.1 æ–¹å¼ä¸€
      for (list <- List(
        List(0),
        List(1,0),
        List(0,1,0),
        List(1,1,0),
        List(88),
        Array("hello")
      )){
        val result =list match {
          case List(0) => "0"
          case List(x,y) => "List(x,y):  " +x+ ", " +y
          case List(0,_*) => "ä»¥0å¼€å¤´çš„æ•°ç»„"
          case List(a) => "List(a) :" + a
          case _ => "something else"
        }
        println(result)
      }
  
  println("===============================")
  ```

- **æ–¹å¼äºŒ**

  ```scala
      //4.2 æ–¹å¼äºŒ
      val list1 =List(1,2,5,7,24)
      val list =List(24)
      list match {
        case first :: second :: rest => println(s"first: $first , second : $second  ,rest : $rest")
        case _ => println("something else")
      }
  
      println("===============================")
  ```

  

### åŒ¹é…å…ƒç»„

------



- ```scala
  //5 åŒ¹é…å…ƒç»„
  for (tuple <- List(
    (0,1),
    (0,0),
    (0,1,0),
    (0,1,1),
    (1,12,66),
    ("hello",true,0.56),
  
  )){
    val result =tuple match {
      case (a,b) => " "+ a+ " , " + b
      case (0,_) => " (0 , _)"
      case (a,1 ,_) => "(a,1, _)" + a
      case (x,y,z) => "(x,y,z)" +x+ " "+y + " " +z+ " "
      case _ => "something else"
    }
  
    println(result)
  
  }
  ```



- **æ‰©å±•**

  ```scala
  // 1 åœ¨å˜é‡å£°æ˜æ—¶ åŒ¹é…
  val (x,y) =(10 ,"hello")
  println(s"x : $x ,y : $y")
  
  val List(first,sceond,_*) = List(12,6,31,69,31)
  println(s"first :$first ,second : $sceond  ")
  
  val  fir :: sec :: rest =List(25,69,6,45)
  println(s"first :$fir ,second : $sec rest : $rest")
  
  //2 for æ¨å¯¼å¼ä¸­è¿›è¡Œæ¨¡å¼åŒ¹é…
  val list :List[(String,Int)]=List(("a",13),("b",65),("c",19))
  
      //2.1 åŸæœ¬çš„éå†æ–¹å¼
      for (elem <- list){
        println(elem._1+ " "+ elem._2 )
      }
  
      //2.2 å°†List çš„å…ƒç´ ç›´æ¥å®šä¹‰ä¸ºå…ƒç»„ å¯¹å˜é‡èµ‹å€¼
      for ((word,count) <- list  ){
        println(word+ ":  "+ count)
      }
  
  
      //2.3 å¯ä»¥ä¸è€ƒè™‘æŸä¸ªä½ç½®çš„å˜é‡ åªéå†key æˆ–è€… value
      for ((word,_) <- list  ){
        println(word)
      }
  
  
      // 2.4 å¯ä»¥æŒ‡å®šæŸä¸ªä½ç½®çš„å€¼å¿…é¡»æ—¶å¤šå°‘
      for (("a" ,count) <- list){
        println(count)
      }
  ```



### åŒ¹é…å¯¹è±¡åŠæ ·ä¾‹ç±»

------

#### å¯¹è±¡

------

> æ¡ˆä¾‹

```scala
package chapter08


object Test04_MatchObject {
  def main(args: Array[String]): Unit = {

    val student =new Student("jack",29)

      //é’ˆå¯¹å¯¹è±¡å®ä¾‹çš„å†…å®¹è¿›è¡ŒåŒ¹é…
      val result = student match {
        case Student("marry",29) => " marry 29"
        case _ => "Else"
      }
    println(result)

  }

}


// å®šä¹‰ç±»
class Student(val name:String,val age :Int)

//å®šä¹‰ä¼´ç”Ÿå¯¹è±¡
object Student {
  def apply(name :String ,age: Int): Student=new Student(name,age)

  // å¿…é¡»å®ç°ä¸€ä¸ªunapplyæ–¹æ³•  ç”¨æ¥æ‹†è§£å¯¹è±¡å±æ€§
  def unapply(student: Student):Option [(String,Int)]={
    if (student==null){None}
    else {Some((student.name,student.age))}
  }

}
```



[^æå–å™¨]: æ•°ç»„ã€åˆ—è¡¨å’Œå…ƒç»„èƒ½ä½¿ç”¨æ¨¡å¼åŒ¹é…ï¼Œéƒ½æ˜¯ä¾é æå–å™¨ (extractor) æœºåˆ¶ï¼Œå®ƒä»¬ä¼´ç”Ÿå¯¹è±¡ä¸­å®šä¹‰äº† `unapply` æˆ– `unapplySeq` æ–¹æ³•ï¼š

+ **unapply**ï¼šç”¨äºæå–å›ºå®šæ•°é‡çš„å¯¹è±¡

+ **unapplySeq**ï¼šç”¨äºæå–ä¸€ä¸ªåºåˆ—

  + ```scala
    def unapplySeq[T](x : scala.Array[T]) : scala.Option[scala.IndexedSeq[T]] =
    { /* compiled code */ }
    ```

    `unapplySeq` è¿”å›ä¸€ä¸ªåºåˆ—ï¼ŒåŒ…å«æ•°ç»„ä¸­çš„æ‰€æœ‰å€¼ï¼Œè¿™æ ·åœ¨æ¨¡å¼åŒ¹é…æ—¶ï¼Œæ‰èƒ½çŸ¥é“å¯¹åº”ä½ç½®ä¸Šçš„å€¼ã€‚

    





#### æ ·ä¾‹ç±»

------

- **å£°æ˜è¯­æ³•**
  - åªéœ€è¦åœ¨ `class` å‰é¢åŠ ä¸Šå…³é”®å­— `case`

```scala
package chapter08

object Test05_MatchCaseClass {
  def main(args: Array[String]): Unit = {

    val student =new Student1("marry",29)

    //é’ˆå¯¹å¯¹è±¡å®ä¾‹çš„å†…å®¹è¿›è¡ŒåŒ¹é…
    val result = student match {
      case Student1("marry",29) => " marry 29"
      case _ => "Else"
    }
    println(result)


  }
}
// å®šä¹‰æ ·ä¾‹ç±»  apply unapply æ–¹æ³•è‡ªåŠ¨ç”Ÿæˆ
case class Student1(val name:String,val age :Int)
```

å£°æ˜æ ·ä¾‹ç±»åï¼Œç¼–è¯‘å™¨è‡ªåŠ¨è¿›è¡Œä»¥ä¸‹é…ç½®ï¼š

- æ„é€ å™¨ä¸­æ¯ä¸ªå‚æ•°éƒ½é»˜è®¤ä¸º `val`ï¼›
- è‡ªåŠ¨åœ°ç”Ÿæˆ `equals, hashCode, toString, copy` ç­‰æ–¹æ³•ï¼›
- ä¼´ç”Ÿå¯¹è±¡ä¸­è‡ªåŠ¨ç”Ÿæˆ `apply` æ–¹æ³•ï¼Œä½¿å¾—å¯ä»¥ä¸ç”¨ new å…³é”®å­—å°±èƒ½æ„é€ å‡ºç›¸åº”çš„å¯¹è±¡ï¼›
- ä¼´ç”Ÿå¯¹è±¡ä¸­è‡ªåŠ¨ç”Ÿæˆ `unapply` æ–¹æ³•ï¼Œä»¥æ”¯æŒæ¨¡å¼åŒ¹é…ã€‚

==é™¤äº†ä¸Šé¢çš„ç‰¹å¾å¤–ï¼Œæ ·ä¾‹ç±»å’Œå…¶ä»–ç±»ç›¸åŒï¼Œå¯ä»¥ä»»æ„æ·»åŠ æ–¹æ³•å’Œå­—æ®µï¼Œæ‰©å±•å®ƒä»¬ã€‚==



### åŒ¹é…åœ¨Forå¾ªç¯ä¸­çš„ç®€åŒ–

------

> éœ€æ±‚:  å¯¹åˆ—è¡¨ä¸­ value._2       è¿›è¡Œä¹˜ä»¥2æ“ä½œ

```scala
val list :List[(String,Int)]=List(("a",13),("b",65),("c",19))

//1 mapè½¬åŒ–å®ç°keyä¸å˜ valueä¹˜2
val newList = list.map( tuple => (tuple._1,tuple._2 * 2))


//2 ç”¨æ¨¡å¼åŒ¹é…å¯¹å…ƒç»„èµ‹å€¼ å®ç°åŠŸèƒ½
val newList2 = list.map(
  tuple => {
    tuple match {
      case (word , count) => (word,count * 2)
    }
  }
)


// 3 çœç•¥lambda è¡¨è¾¾å¼çš„å†™æ³• è¿›è¡Œç®€åŒ–
val newList3 = list.map {
  case (word, count) => (word, count * 2)
}

println(newList)
println(newList2)
println(newList3)
```





## åå‡½æ•°

==åå‡½æ•°ï¼Œå…¶å®å°±æ˜¯å¯¹é›†åˆä¸­ç¬¦åˆæ¡ä»¶çš„æ•°æ®è¿›è¡Œå¤„ç†çš„å‡½æ•°==

åå‡½æ•°ä¹Ÿæ˜¯å‡½æ•°çš„ä¸€ç§ï¼Œé€šè¿‡åå‡½æ•°æˆ‘ä»¬å¯ä»¥æ–¹ä¾¿çš„**å¯¹è¾“å…¥å‚æ•°åšæ›´ç²¾ç¡®çš„æ£€æŸ¥**ã€‚

- **ä¾‹å¦‚**
  - åå‡½æ•°çš„è¾“å…¥ç±»å‹ä¸ºIntï¼Œä½†æ˜¯æˆ‘ä»¬åªè€ƒè™‘æ•°å€¼ä¸º1çš„æ—¶å€™ï¼Œæ•°æ®è¯¥å¦‚ä½•å¤„ç†ï¼Œå…¶ä»–ä¸è€ƒè™‘ã€‚



- **è¯­æ³•**

  ```scala
  	  å‡½æ•°å						 è¿”å›å€¼ç±»å‹
  		ğŸ‘‡							   ğŸ‘‡		
  val  positiveAbs: PartialFunction[Int,Int] ={ }
                                     ğŸ‘†
                                   å‚æ•°ç±»å‹
  ```

 

```scala
    // åå‡½æ•°çš„åº”ç”¨ æ±‚ç»å¯¹å€¼
    //å¯¹è¾“å…¥çš„æ•°æ®åˆ†ä¸ºä¸åŒçš„æƒ…å½¢ ï¼š æ­£  ã€è´Ÿ ã€0   
                                    // è¾“å…¥Intéƒ¨åˆ†è¾“å‡ºInt
    val  positiveAbs: PartialFunction[Int,Int] ={
      case x if x>0 => x
    }

    val  negativeAbs: PartialFunction[Int,Int] ={
      case x if x<0 => -x
    }

    val  zeroAbs: PartialFunction[Int,Int] ={
      case 0 => 0
    }


    //å‡½æ•°å¼ç¼–ç¨‹çš„é­…åŠ›       ä¸€å¥è¯ç¼–ç¨‹
    def abs(x:Int) :Int = (positiveAbs orElse negativeAbs orElse zeroAbs) (x)

    println(abs(-66))
    println(abs(68))
    println(abs(0))

```





# äºŒã€å¼‚å¸¸

scalaå¼‚å¸¸å¤„ç†æ•´ä½“ä¸Šçš„è¯­æ³•å’Œåº•å±‚å¤„ç†ç»†èŠ‚å’Œjavaéå¸¸ç±»ä¼¼ã€‚

**Javaå¼‚å¸¸å¤„ç†ï¼š**

- ç”¨`try`è¯­å¥åŒ…å›´è¦æ•è·å¼‚å¸¸çš„å—ï¼Œå¤šä¸ªä¸åŒ`catch`å—ç”¨äºæ•è·ä¸åŒçš„å¼‚å¸¸ï¼Œ`finally`å—ä¸­æ˜¯æ•è·å¼‚å¸¸ä¸å¦éƒ½ä¼šæ‰§è¡Œçš„é€»è¾‘ã€‚

  ```java
  try {
      int a = 0;
      int b = 0;
      int c = a / b;
  } catch (ArithmeticException e) {
      e.printStackTrace();
  } catch (Exception e) {
      e.printStackTrace();
  } finally {
      System.out.println("finally");
  }
  ```

  



**scalaå¼‚å¸¸å¤„ç†ï¼š**

- `try`åŒ…å›´è¦æ•è·å¼‚å¸¸çš„å†…å®¹ï¼Œ`catch`ä»…ä»…æ˜¯å…³é”®å­—ï¼Œå°†æ•è·å¼‚å¸¸çš„æ‰€æœ‰é€»è¾‘åŒ…å›´åœ¨`catch`å—ä¸­ã€‚`finally`å—å’Œjavaä¸€æ ·éƒ½ä¼šæ‰§è¡Œï¼Œä¸€èˆ¬ç”¨äºå¯¹è±¡çš„æ¸…ç†å·¥ä½œã€‚

- scalaä¸­æ²¡æœ‰ç¼–è¯‘æœŸå¼‚å¸¸ï¼Œ==æ‰€æœ‰å¼‚å¸¸éƒ½æ˜¯è¿è¡Œæ—¶å¤„ç†ã€‚==

- scalaä¸­ä¹Ÿæ˜¯ç”¨`throw`å…³é”®å­—æŠ›å‡ºå¼‚å¸¸ï¼Œæ‰€æœ‰å¼‚å¸¸éƒ½æ˜¯`Throwable`çš„å­ç±»ï¼Œ`throw`è¡¨è¾¾å¼æ˜¯æœ‰ç±»å‹çš„ï¼Œå°±æ˜¯`Nothing`ã€‚`Nothing`ä¸»è¦ç”¨åœ¨ä¸€ä¸ªå‡½æ•°æ€»æ˜¯ä¸èƒ½æ­£å¸¸å·¥ä½œï¼Œæ€»æ˜¯æŠ›å‡ºå¼‚å¸¸çš„æ—¶å€™ç”¨ä½œè¿”å›å€¼ç±»å‹ã€‚

- javaä¸­ç”¨äº†`throws`å…³é”®å­—å£°æ˜æ­¤æ–¹æ³•å¯èƒ½å¼•å‘çš„å¼‚å¸¸ä¿¡æ¯ï¼Œåœ¨scalaä¸­å¯¹åº”åœ°ä½¿ç”¨`@throws[ExceptionList]`æ³¨è§£æ¥å£°æ˜ï¼Œç”¨æ³•å·®ä¸å¤šã€‚

  ```scala
  package chapter09plus
  
  object Test01_Exception {
    def main(args: Array[String]): Unit = {
      try {
  
        val n = 10 / 1
      } catch {
        case e: ArithmeticException =>
          println("å‘ç”Ÿç®—æ•°å¼‚å¸¸")
  
        case e: Exception =>
          println("å‘ç”Ÿä¸€èˆ¬å¼‚å¸¸")
  
      } finally {
        println("å¤„ç†ç»“æœ")
      }
    }
  }
  
  ```

  

















































